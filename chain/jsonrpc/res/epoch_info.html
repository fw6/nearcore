<html>

<head>
    <style>
        table {
            width: 100%;
            border-collapse: collapse;
        }

        table,
        th,
        td {
            border: 1px solid black;
        }

        td {
            text-align: left;
            vertical-align: top;
            padding: 8px;
        }

        th {
            text-align: center;
            vertical-align: center;
            padding: 8px;
            background-color: lightgrey;
        }

        tr.active {
            background-color: #eff8bf;
        }

        .producer-green {
            background-color: lightgreen;
        }

        .producer-yellow {
            background-color: lightyellow;
        }

        .producer-red {
            background-color: lightcoral;
        }

        .producer-dark-red {
            background-color: red;
        }
    </style>
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js"></script>
    <script>
        function convertTime(millis) {
            let total_seconds = Math.floor(millis / 1000);
            let hours = Math.floor(total_seconds / 3600)
            let minutes = Math.floor((total_seconds - (hours * 3600)) / 60)
            let seconds = total_seconds - (hours * 3600) - (minutes * 60)
            if (hours > 0) {
                if (minutes > 0) {
                    return `${hours}h ${minutes}m ${seconds}s`
                } else {
                    return `${hours}h ${seconds}s`
                }
            }
            if (minutes > 0) {
                return `${minutes}m ${seconds}s`
            }
            return `${seconds}s`
        }
        function humanFileSize(bytes, si = false, dp = 1) {
            const thresh = si ? 1000 : 1024;

            if (Math.abs(bytes) < thresh) {
                return bytes + ' B';
            }

            const units = si
                ? ['kB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB']
                : ['KiB', 'MiB', 'GiB', 'TiB', 'PiB', 'EiB', 'ZiB', 'YiB'];
            let u = -1;
            const r = 10 ** dp;

            do {
                bytes /= thresh;
                ++u;
            } while (Math.round(Math.abs(bytes) * r) / r >= thresh && u < units.length - 1);


            return bytes.toFixed(dp) + ' ' + units[u];
        }

        function process_responses(data, epoch_data) {
            let validatorMap = new Map();
            let maxShards = 0;
            epoch_data.status_response.EpochInfo.forEach((epoch, index) => {
                {
                    let row = $('<tr>');
                    row.append($('<td>').append(epoch.epoch_id));
                    row.append($('<td>').append(epoch.height));
                    row.append($('<td>').append(epoch.protocol_version));
                    if (epoch.first_block === null) {
                        if (index == 0) {
                            let blocks_remaining = (epoch.height - data.sync_info.latest_block_height);
                            let milliseconds_remaining = blocks_remaining * data.detailed_debug_status.block_production_delay_millis;
                            row.append($('<td>').append("Next epoch - in " + blocks_remaining + " blocks "));
                            $('.js-next-epoch').append("Next epoch in " + convertTime(milliseconds_remaining));
                        } else {
                            row.append($('<td>'));
                        }
                        row.append($('<td>'));
                    } else {
                        row.append($('<td>').append(epoch.first_block[0]));
                        row.append($('<td>').append(convertTime(Date.now() - Date.parse(epoch.first_block[1])) + " ago"));
                    }
                    $('.js-tbody-epochs').append(row);
                }

                $('.js-head-validators').append($('<th>').append(epoch.epoch_id.substr(0, 10) + " [" + epoch.validators.length, ", " + epoch.chunk_only_producers.length + "]"));
                // Use 2 bits to encode the validator's role in a given epoch.
                // 00 -- not participated
                // 01 -- block producer
                // 10 -- chunk only producer
                epoch.validators.forEach(validator => {
                    let account_id = validator.account_id;
                    let value = 2 ** (index * 2);
                    if (validatorMap.has(account_id)) {
                        validatorMap.set(account_id, validatorMap.get(account_id) + value);
                    } else {
                        validatorMap.set(account_id, value);
                    }
                });
                epoch.chunk_only_producers.forEach(producer => {
                    let account_id = producer;
                    let value = 2 ** (index * 2 + 1);
                    if (validatorMap.has(account_id)) {
                        validatorMap.set(account_id, validatorMap.get(account_id) + value);
                    } else {
                        validatorMap.set(account_id, value);
                    }
                });

                {
                    let row = $('<tr>');
                    row.append($('<td>').append(epoch.epoch_id));

                    epoch.shards_size_and_parts.forEach(element => {
                        let cell = $('<td>').append(humanFileSize(element[0]));
                        if (element[2] == true) {
                            cell.css('background-color', 'orange');
                        }
                        row.append(cell);
                        row.append($('<td>').append(element[1]));
                    });
                    $('.js-tbody-shard-sizes').append(row);
                }
                maxShards = Math.max(epoch.shards_size_and_parts.length, maxShards);
            });

            let validator_epoch_cell_map = new Map();
            validatorMap.forEach((value, key) => {
                let single_validator_epoch_cell_map = new Map();
                let row = $('<tr>').append($('<td>').append(key));
                for (i = 0; i < epoch_data.status_response.EpochInfo.length; i += 1) {
                    let cell = $('<td>');
                    if (value & 2 ** (i * 2)) {
                        cell.append('B ');
                    } else if (value & 2 ** (i * 2 + 1)) {
                        cell.append('C ');
                    } else {
                        cell.append('0');
                    }
                    row.append(cell);
                    single_validator_epoch_cell_map.set(epoch_data.status_response.EpochInfo[i].epoch_id, cell);
                }
                validator_epoch_cell_map.set(key, single_validator_epoch_cell_map)
                $('.js-tbody-validators').append(row);
            });

            let next_epoch = epoch_data.status_response.EpochInfo[0];
            let current_epoch = epoch_data.status_response.EpochInfo[1];

            request_validator_stats((validator_data) => {
                validator_data.result.current_validators.forEach(element => {
                    let stake = Number((element.stake / 1000000000000000000000000).toFixed(1));
                    let produced_fraction = (element.num_produced_blocks + element.num_produced_chunks) / (element.num_expected_blocks + element.num_expected_chunks);
                    let cell_class = ""
                    if (produced_fraction > 0.95) {
                        cell_class = "producer-green";
                    } else if (produced_fraction > 0.90) {
                        cell_class = "producer-yellow";
                    } else if (produced_fraction > 0.70) {
                        cell_class = "producer-red";
                    } else {
                        cell_class = "producer-dark-red";
                    }
                    validator_epoch_cell_map.get(element.account_id).get(current_epoch.epoch_id).append(
                        `${stake} ${Math.round(produced_fraction * 100)}% <br> (${element.num_produced_blocks} / ${element.num_expected_blocks}) <br> (${element.num_produced_chunks} / ${element.num_expected_chunks})`
                    ).addClass(cell_class);
                });
                validator_data.result.next_validators.forEach(element => {
                    let stake = Number((element.stake / 1000000000000000000000000).toFixed(1));
                    validator_epoch_cell_map.get(element.account_id).get(next_epoch.epoch_id).append(
                        `${stake}`);
                });
            });
            for (const x of Array(maxShards).keys()) {
                $('.js-head-shard-sizes').append($('<th colspan="2">').append("Shard " + x));
                $('.js-head-shard-sizes-line2').append($('<th>').append("Size"));
                $('.js-head-shard-sizes-line2').append($('<th>').append("Parts"));

            }
        }

        function request_epoch_info(status_data) {
            $.ajax({
                type: "GET",
                url: "/debug/api/epoch_info",
                success: epoch_data => {
                    process_responses(status_data, epoch_data);
                },
                dataType: "json",
                error: function (errMsg, textStatus, errorThrown) {
                    alert("Failed: " + textStatus + " :" + errorThrown);
                },
                contentType: "application/json; charset=utf-8",
            })
        }

        function request_validator_stats(on_success) {
            $.ajax({
                type: "POST",
                url: "/",
                data: JSON.stringify({
                    "jsonrpc": "2.0",
                    "id": "dontcare",
                    "method": "validators",
                    "params": [null]
                }),
                success: validator_data => {
                    on_success(validator_data);
                },
                dataType: "json",
                error: function (errMsg, textStatus, errorThrown) {
                    alert("Failed: " + textStatus + " :" + errorThrown);
                },
                contentType: "application/json; charset=utf-8",
            })
        }

        $(document).ready(() => {
            $.ajax({
                type: "GET",
                url: "/debug/api/status",
                success: data => {
                    request_epoch_info(data);
                },
                dataType: "json",
                error: function (errMsg, textStatus, errorThrown) {
                    alert("Failed: " + textStatus + " :" + errorThrown);
                },
                contentType: "application/json; charset=utf-8",
            })
        });
    </script>
</head>

<body>

    <h2>Epochs </h2>
    <h3><span class="js-next-epoch"></span></h3>

    <table>
        <thead>
            <tr>
                <th>Epoch id</th>
                <th>Start height</th>
                <th>Protocol version</th>
                <th>First block</th>
                <th>Epoch start</th>
            </tr>
        </thead>
        <tbody class="js-tbody-epochs">
        </tbody>
    </table>


    <h2> Validators </h2>

    <table>
        <thead>
            <tr class="js-head-validators">
                <th>Account ID</th>
            </tr>
        </thead>
        <tbody class="js-tbody-validators">
        </tbody>
    </table>

    <h2> Shard sizes </h2>

    <table>
        <thead>
            <tr class="js-head-shard-sizes">
                <th rowspan="2">Epoch Id</th>
            </tr>
            <tr class="js-head-shard-sizes-line2">

            </tr>
        </thead>
        <tbody class="js-tbody-shard-sizes">
        </tbody>
    </table>
    Orange color means, that a given shard was requested by other peer for syncing.
</body>

</html>